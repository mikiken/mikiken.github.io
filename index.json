[{"categories":null,"content":"この記事は、CAMPHOR- Advent Calendar 2023 の21日目の記事です。 ","date":"2023-12-21","objectID":"/posts/impl-ogp-image/:0:0","tags":null,"title":"自作サイト用にOGP画像を自動生成するツールを作った","uri":"/posts/impl-ogp-image/"},{"categories":null,"content":"はじめに TwitterとかSlackなどで、URLを貼り付けると、以下のように記事のサムネイルが表示されることがあると思います。 SNS向けに記事のメタ情報を記述するプロトコルとしては、Open Graph protocol というものが広く使われています。 今回は、このサイトにOGPに準拠した記事のサムネイルを自動生成するツール作ってみました。 ","date":"2023-12-21","objectID":"/posts/impl-ogp-image/:1:0","tags":null,"title":"自作サイト用にOGP画像を自動生成するツールを作った","uri":"/posts/impl-ogp-image/"},{"categories":null,"content":"方針 自分しか使わないツールなので、とりあえず以下のような方針で進めることにしました。 サムネイルには、記事のタイトル, ユーザー名, アイコン, サイト名を表示する 記事の.mdファイルのパスを渡すと、Front Matterから記事タイトルを取得して、サムネイルを生成する Hugoと連携させる可能性を一応考え、Goで実装する SVGでサムネイルのテンプレートを用意しておき、そこに記事タイトルを埋め込み、PNGで出力する ","date":"2023-12-21","objectID":"/posts/impl-ogp-image/:2:0","tags":null,"title":"自作サイト用にOGP画像を自動生成するツールを作った","uri":"/posts/impl-ogp-image/"},{"categories":null,"content":"実装してみる ","date":"2023-12-21","objectID":"/posts/impl-ogp-image/:3:0","tags":null,"title":"自作サイト用にOGP画像を自動生成するツールを作った","uri":"/posts/impl-ogp-image/"},{"categories":null,"content":"雛形の用意 まずはサムネイルの雛形を用意します。適当にPowerPointで雛形を作成し、Inkscapeで調整すると以下のような感じになりました。適当に作ったらZennのパクリみたいになってしまった 雛形のSVGファイルをテキストエディタで開き、いろいろ手直しを加えた結果、以下のようになりました。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e \u003csvg width=\"1200\" height=\"630\" viewBox=\"0 0 317.5 166.6875\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:svg=\"http://www.w3.org/2000/svg\"\u003e \u003cdefs\u003e \u003cstyle\u003e \u003c![CDATA[@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;700\u0026display=swap');]]\u003e .noto-sans{font-family: 'Noto Sans JP', sans-serif;} \u003c/style\u003e \u003clinearGradient x1=\"802.40997\" y1=\"636.23401\" x2=\"157.59\" y2=\"-132.23399\" gradientUnits=\"userSpaceOnUse\" spreadMethod=\"reflect\" id=\"fill\"\u003e \u003cstop offset=\"0\" stop-color=\"#265073\"/\u003e \u003cstop offset=\"0.06\" stop-color=\"#265073\"/\u003e \u003cstop offset=\"1\" stop-color=\"#9AD0C2\"/\u003e \u003c/linearGradient\u003e \u003cclipPath clipPathUnits=\"userSpaceOnUse\" id=\"clipPath\"\u003e \u003ccircle cx=\"-102.56742\" cy=\"102.00123\" style=\"stroke-width:0.246697\" r=\"52.916668\" /\u003e \u003c/clipPath\u003e \u003c/defs\u003e \u003cg transform=\"translate(27.425752,2.2446047)\"\u003e \u003cg style=\"overflow:hidden\" transform=\"matrix(0.33075834,0,0,0.33075834,-27.425752,-2.2446047)\"\u003e \u003crect x=\"0\" y=\"0\" width=\"960\" height=\"504\" fill=\"#ffffff\" /\u003e \u003crect x=\"0\" y=\"0\" width=\"960\" height=\"504\" fill=\"url(#fill)\" style=\"fill:url(#fill)\" /\u003e \u003cpath d=\"M 48,62.4088 C 48,49.4805 58.4805,39 71.4088,39 H 887.591 C 900.519,39 911,49.4805 911,62.4088 V 441.591 C 911,454.52 900.519,465 887.591,465 H 71.4088 C 58.4805,465 48,454.52 48,441.591 Z\" fill=\"#ffffff\" fill-rule=\"evenodd\" fill-opacity=\"0.94902\" /\u003e \u003cg clip-path=\"url(#clip2)\"\u003e \u003cuse width=\"100%\" height=\"100%\" xlink:href=\"#img1\" transform=\"matrix(0.818182,0,0,0.818182,74,384)\" x=\"0\" y=\"0\" /\u003e \u003c/g\u003e \u003ctext class=\"noto-sans\" font-size=\"27px\" font-weight=\"300\" transform=\"translate(150.168,424)\"\u003emikiken (@mikikeen)\u003c/text\u003e \u003ctext fill=\"#7f7f7f\" class=\"noto-sans\" font-size=\"21px\" font-weight=\"300\" transform=\"translate(772.616,443)\"\u003emikiken.net\u003c/text\u003e \u003cforeignObject x=\"80\" y=\"74\" width=\"800\" height=\"500\"\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\"\u003e \u003cdiv class=\"noto-sans\" style=\"font-size:48px; font-weight:700;\"\u003e {{.article_title}} \u003c/div\u003e \u003c/html\u003e \u003c/foreignObject\u003e \u003c/g\u003e \u003cimage width=\"106\" height=\"106\" preserveAspectRatio=\"none\" xlink:href=\"\u003cアイコンをbase64エンコーディングした文字列\u003e\" id=\"avatar\" x=\"-155.48409\" y=\"49.08456\" clip-path=\"url(#clipPath)\" transform=\"matrix(0.19915161,0,0,0.19915161,27.96638,114.72905)\" /\u003e \u003c/g\u003e \u003c/svg\u003e 上記のSVGファイルのうち、 \u003cforeignObject x=\"80\" y=\"74\" width=\"800\" height=\"500\"\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\"\u003e \u003cdiv class=\"noto-sans\" style=\"font-size:48px; font-weight:700;\"\u003e {{.article_title}} \u003c/div\u003e \u003c/html\u003e \u003c/foreignObject\u003e の部分が、記事のタイトルを埋め込む部分です。{{.article_title}}の部分を、あとで記事のタイトルに置き換えます。 一応、ポイントとしては、 テンプレートにローカルのフォントを用いると、実行時にフォントのバイナリを手元に用意しておく必要があり面倒なので、Webフォントを使うようにした 記事のタイトルが長い場合、改行を入れたいが、SVGの仕様では要素幅に合わせて自動的にテキストを折り返す機能がないっぽい。そこで、foreignObject要素を使って、HTMLをSVGに埋め込むようにした という感じです。 ","date":"2023-12-21","objectID":"/posts/impl-ogp-image/:3:1","tags":null,"title":"自作サイト用にOGP画像を自動生成するツールを作った","uri":"/posts/impl-ogp-image/"},{"categories":null,"content":"Goでコードを書く 実装のコードを載せようかとも思ったんですが、上で言った内容をただ書いてるだけなので、割愛します。実際のコードは、以下のリポジトリにあります。 少しトリッキーなことをしている点としては、PNG画像を生成するために、ヘッドレスブラウザを起動して、スクリーンショットを撮っているところです。Webフォントを埋め込んでいるため、今回はこの方法を取っているんですが、少し大掛かり感はあります。 func convertToPng(svgContent []byte) []byte { // get svg size width, height, err := getSvgSize(svgContent) if err != nil { fmt.Println(err) } // launch headless browser page, err := rod.New().MustConnect().Page(proto.TargetCreateTarget{}) if err != nil { fmt.Println(err) } // set svg content to page if err = page.SetDocumentContent(string(svgContent)); err != nil { fmt.Println(err) } // take screenshot img, err := page.MustWaitStable().Screenshot(true, \u0026proto.PageCaptureScreenshot{ Format: proto.PageCaptureScreenshotFormatPng, Clip: \u0026proto.PageViewport{ X: 7.5, Y: 7.5, Width: float64(width), Height: float64(height), Scale: 1, }, FromSurface: true, }) if err != nil { fmt.Println(err) } return img } Goを書くのは初めてだったんですが、ChatGPTに質問しつつ1日くらいで大体書けました。 ","date":"2023-12-21","objectID":"/posts/impl-ogp-image/:3:2","tags":null,"title":"自作サイト用にOGP画像を自動生成するツールを作った","uri":"/posts/impl-ogp-image/"},{"categories":null,"content":"Hugo側でOGP画像のパスを設定する あとは、Hugoが生成するHTMLのhead要素の中に、OGPに準拠するようにmeta要素を追加します。 Hugo側でも、OGPやTwitter Cardの設定の雛形は用意されており、layouts/partials/head/meta.htmlに以下のように書くと、必要なmeta要素を生成してくれます。 {{- template \"_internal/opengraph.html\" . -}} {{- template \"_internal/twitter_cards.html\" . -}} 自分は少しカスタマイズしたかったので、以下のような記述を追加しました。 {{- template \"_internal/opengraph.html\" . -}} {{ if .Params.autoGenOgpImg }} \u003cmeta property=\"og:image\" content=\"{{ .Site.BaseURL }}images/ogp/content/{{.File.Dir}}{{.File.BaseFileName}}.png\"\u003e \u003cmeta name=\"twitter:card\" content=\"summary_large_image\"\u003e \u003cmeta name=\"twitter:image\" content=\"{{ .Site.BaseURL }}images/ogp/{{.File.Dir}}{{.File.BaseFileName}}.png\"\u003e {{- else -}} \u003cmeta name=\"twitter:card\" content=\"summary\"\u003e {{- end -}} {{- /* Twitter Card Configuration */}} \u003cmeta name=\"twitter:title\" content=\"{{ .Title }}\"\u003e \u003cmeta name=\"twitter:description\" content=\"{{ with .Description }}{{ . }}{{ else }}{{if .IsPage}}{{ .Summary }}{{ else }}{{ with .Site.Params.description }}{{ . }}{{ end }}{{ end }}{{ end -}}\"\u003e {{- $twitterSite := \"\" }} {{- with site.Params.social }} {{- if reflect.IsMap . }} {{- $twitterSite = .twitter }} {{- end }} {{- else }} {{- with site.Social.twitter }} {{- $twitterSite = . }} {{- warnf \"The social key in site configuration is deprecated. Use params.social.twitter instead.\" }} {{- end }} {{- end }} {{- with $twitterSite }} {{- $content := . }} {{- if not (strings.HasPrefix . \"@\") }} {{- $content = printf \"@%v\" $twitterSite }} {{- end }} \u003cmeta name=\"twitter:site\" content=\"{{ $content }}\"\u003e {{- end }} しかし書き方をミスってるっぽく、現状うまくTwitter Cardにサムネイルが表示されない ","date":"2023-12-21","objectID":"/posts/impl-ogp-image/:3:3","tags":null,"title":"自作サイト用にOGP画像を自動生成するツールを作った","uri":"/posts/impl-ogp-image/"},{"categories":null,"content":"使い方 $ ogp-img-generator \u003c雛形のSVGファイルのパス\u003e \u003c記事の.mdファイルのパス\u003e* みたいなコマンドを打つと、static/images/ogp/content/以下に、記事のファイルパスに対応したサムネイルのPNG画像が生成されます。 また、Gitコマンドと組み合わせて、以下のようなコマンドを実行すると、変更された記事に対してのみサムネイルを生成できます。 git add -N . \u0026\u0026 git diff --name-only | grep \\.md$ | xargs ogp-img-generator \u003c雛形のSVGファイルのパス\u003e \u0026\u0026 git reset HEAD ","date":"2023-12-21","objectID":"/posts/impl-ogp-image/:4:0","tags":null,"title":"自作サイト用にOGP画像を自動生成するツールを作った","uri":"/posts/impl-ogp-image/"},{"categories":null,"content":"今後の課題など 上の処理をCIでやるようにしたい Goで実装したので、go installするだけで実行バイナリが生成でき、割とやりやすそう Twitter Cardが上手く出ないのを直す ","date":"2023-12-21","objectID":"/posts/impl-ogp-image/:5:0","tags":null,"title":"自作サイト用にOGP画像を自動生成するツールを作った","uri":"/posts/impl-ogp-image/"},{"categories":null,"content":"この記事は CAMPHOR- Advent Calendar 2023 の13日目の記事です。 ","date":"2023-12-13","objectID":"/posts/td4-fpga/:0:0","tags":null,"title":"「CPUの創りかた」のTD4をFPGAで実装してみた","uri":"/posts/td4-fpga/"},{"categories":null,"content":"はじめに 「CPUの創りかた」という本をご存知でしょうか？2003年に出版された本で、汎用ロジックIC(74シリーズ)を使って、簡単な4bitのCPUを作ります。本のタイトルから、デジタル回路の話が多そうだという印象を持つかもしれませんが、LED点灯回路の抵抗値の計算といった、基本的なアナログ回路の内容から丁寧に解説されている名著です。今年で発売から20年を迎えますが、未だに根強い人気を誇っており、現在では30刷以上重版されているようです。 僕の通う大学では、3年生後期に、FPGAで何らかのデジタル回路を実装するという実験があります。そこで、この本の内容をFPGAで実装してみました。 大学の実験で「CPUの創りかた」のTD4をFPGAで実装してみた pic.twitter.com/Oqk6r73JyZ — mikiken (@mikikeen) November 6, 2023 ","date":"2023-12-13","objectID":"/posts/td4-fpga/:1:0","tags":null,"title":"「CPUの創りかた」のTD4をFPGAで実装してみた","uri":"/posts/td4-fpga/"},{"categories":null,"content":"作ったもの 「CPUの創りかた」では、TD4という4bitのCPUを段階を分けて作っていきます。 TD4の仕様をざっくり説明すると、 命令長8bit (オペコード 4bit, オペランド 4bit) 演算用のレジスタ(4bit)が2つ という感じです。 実行できる命令としては、以下の12種類があります。 ADD A, Im ADD B, Im MOV A, Im MOV B, Im MOV A, B MOV B, A JMP Im JNC Im キャリーフラグが0のとき、即値Imで指定されたアドレスにジャンプする IN A 入力端子からデータを入力し、Aレジスタに代入する IN B 入力端子からデータを入力し、Bレジスタに代入する OUT B Bレジスタの値を出力端子に出力する なお、OUT A命令は存在しない。 OUT Im 即値Imを出力端子に出力する なお、リポジトリはこれです。 あと、学校の授業で成果発表したときのスライドを一応載せときます ","date":"2023-12-13","objectID":"/posts/td4-fpga/:2:0","tags":null,"title":"「CPUの創りかた」のTD4をFPGAで実装してみた","uri":"/posts/td4-fpga/"},{"categories":null,"content":"実装方法 基本的には本に書いてある通りに実装しました。具体的には、 レジスタ ALU プログラムカウンタ 命令デコーダ ROM の順に実装しました。 なお、実装に使った(実験で渡された)FPGAボードは、PowerMedusa MU500-RXです。 三菱電機マイコン機器ソフトウエアが出しているFPGAボードで、AlteraのEP4CE30F23I7NっていうFPGAが載ってるらしい。 ほぼ本に書いてある順で実装したんですが、ROMだけ実装方針に悩んだので最後に回しました。 本だと8bitをDIPスイッチを16個並べてROMを表現しているんですが、今回使ったFPGAボードには8bitのDIPスイッチが2個しか搭載されていませんでした。 そこで、Verilogを使って、ROMの各アドレスに対して決め打ちした命令を返す素子を書き、ROMを表現することにしました。 module rom( input [3:0] address, output [7:0] data ); function [7:0] select; input [3:0] address; case (address) //Ramen timer! 4'b0000: select = 8'b10110111; // OUT 0111 4'b0001: select = 8'b00000001; // ADD A,0001 4'b0010: select = 8'b11100001; // JNC 0001 4'b0011: select = 8'b00000001; // ADD A,0001 4'b0100: select = 8'b11100011; // JNC 0011 4'b0101: select = 8'b10110110; // OUT 0110 4'b0110: select = 8'b00000001; // ADD A,0001 4'b0111: select = 8'b11100110; // JNC 0110 4'b1000: select = 8'b00000001; // ADD A,0001 4'b1001: select = 8'b11101000; // JNC 1000 4'b1010: select = 8'b10110000; // OUT 0000 4'b1011: select = 8'b10110100; // OUT 0100 4'b1100: select = 8'b00000001; // ADD 0001 4'b1101: select = 8'b11101010; // JNC 1010 4'b1110: select = 8'b10111000; // OUT 1000 4'b1111: select = 8'b11111111; // JMP 1111 default: select = 8'bxxxxxxxx; /* //LED chikachika! 4'b0000: select = 8'b10110011; // OUT 0011 4'b0001: select = 8'b10110110; // OUT 0110 4'b0010: select = 8'b10111100; // OUT 1100 4'b0011: select = 8'b10111000; // OUT 1000 4'b0100: select = 8'b10111000; // OUT 1000 4'b0101: select = 8'b10111100; // OUT 1100 4'b0110: select = 8'b10110110; // OUT 0110 4'b0111: select = 8'b10110011; // OUT 0011 4'b1000: select = 8'b10110001; // OUT 0001 4'b1001: select = 8'b11110000; // JMP 0000 4'b1010: select = 8'b00000000; 4'b1011: select = 8'b00000000; 4'b1100: select = 8'b00000000; 4'b1101: select = 8'b00000000; 4'b1110: select = 8'b00000000; 4'b1111: select = 8'b00000000; default: select = 8'bxxxxxxxx; */ endcase endfunction assign data = select(address); endmodule 今回使ったFPGAボードはQuartusが使えるので、このVerilogのコードを回路図上のコンポーネントとしてexportし、ROMを実装しました。 ","date":"2023-12-13","objectID":"/posts/td4-fpga/:3:0","tags":null,"title":"「CPUの創りかた」のTD4をFPGAで実装してみた","uri":"/posts/td4-fpga/"},{"categories":null,"content":"感想など ブラックボックスだと思っていたCPUについて、少しは理解が深まったと思います。今度はもう少し大規模なCPUをHDLで書いてみたいですね。 どうでもいいことなんですが、気軽に最初のツイートをしたところ、思ったより反響があって驚きました。やはり自作OS, 自作CPU, 自作言語は人類の三大欲求 ","date":"2023-12-13","objectID":"/posts/td4-fpga/:4:0","tags":null,"title":"「CPUの創りかた」のTD4をFPGAで実装してみた","uri":"/posts/td4-fpga/"},{"categories":null,"content":"同じ内容をZennのスクラップにも書いたんですが、こっちにも一応書いとく 本の記述に従い環境構築をしてみた ※手元の環境はUbuntu 20.04.6 LTS (WSL2) しかし、5. ブートの説明通りにrun.shを記述し実行したところ、以下のようなエラーが出た ❯ ./run.sh + QEMU=qemu-system-riscv32 + qemu-system-riscv32 -machine virt -bios default -nographic -serial mon:stdio --no-reboot qemu-system-riscv32: Unable to load the RISC-V firmware \"opensbi-riscv32-virt-fw_jump.bin\" パッと見た感じ、QEMUが-bios defaultで呼び出すファームウェアが、本の執筆当時とは変わっていそう(?) そこで、run.shを以下のように変更した #!/bin/bash set -xue # QEMUの実行バイナリへのパス QEMU=qemu-system-riscv32 # QEMUを起動 $QEMU -machine virt -bios opensbi-riscv32-generic-fw_dynamic.bin -nographic -serial mon:stdio --no-reboot すると、エラー自体は出なくなったが、QEMUを起動しても何も表示されない ❯ ./run.sh + QEMU=qemu-system-riscv32 + qemu-system-riscv32 -machine virt -bios opensbi-riscv32-generic-fw_dynamic.bin -nographic -serial mon:stdio --no-reboot そこで、以下の手順を試した aptで入れたQEMU関係のパッケージを全てアンインストール riscv-gnu-toolchainをソースコードからビルドする QEMUをソースコードからビルドする ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:0","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"aptで入れたQEMU関係のパッケージを全てアンインストール sudo apt-get remove --purge \"qemu-*\" ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:1","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"riscv-gnu-toolchainをソースコードからビルドする ビルドに必要なパッケージをインストールしておく。 sudo apt install -y texinfo bison flex libgmp-dev 環境によっては、上記以外にも足りないパッケージがあるかもしれないので、ビルド実行後にエラーが出たら適宜インストールしてから再実行する。 以下のコマンドを実行し、ソースコードからriscv-gnu-toolchainをビルドする。 cd ~ git clone --depth=1 https://github.com/riscv-collab/riscv-gnu-toolchain.git cd riscv-gnu-toolchain/ ./configure --prefix=/opt/riscv32 --with-arch=rv32i --with-abi=ilp32 sudo make ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:2","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"QEMUをソースコードからビルドする この本が書かれたのが2023年の8月頃なので、当時の安定リリースであるQEMUのv8.0系をソースコードからビルドし、インストールする。 ビルドに必要なパッケージをインストールしておく。 sudo apt install -y pkg-config ninja-build libglib2.0 libpixman-1-dev 環境によっては、上記以外にも足りないパッケージがあるかもしれないので、ビルド実行後にエラーが出たら適宜インストールしてから再実行する。 以下のコマンドを実行する。 mkdir ~/qemu \u0026\u0026 cd ~/qemu git clone --depth=1 --branch stable-8.0 https://github.com/qemu/qemu.git sudo mkdir /opt/qemu-system-riscv32 sudo ./configure --target-list=riscv32-softmmu --prefix=/opt/qemu-system-riscv32/ sudo make -j $(nproc) sudo make install ビルドが完了すると、上の--prefixで指定したパスにqemu-system-riscv32という実行バイナリが生成されているはず。そのディレクトリに対してPATHを通す。 すなわち.bashrcに以下を追加する。 export PATH=\"$PATH:/opt/qemu-system-riscv32/bin\" ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:3","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"動作確認 本の記述通りにrun.shを記述し、実行した。 ❯ ./run.sh + QEMU=qemu-system-riscv32 + qemu-system-riscv32 -machine virt -bios default -nographic -serial mon:stdio --no-reboot OpenSBI v1.2 ____ _____ ____ _____ / __ \\ / ____| _ \\_ _| | | | |_ __ ___ _ __ | (___ | |_) || | | | | | '_ \\ / _ \\ '_ \\ \\___ \\| _ \u003c | | | |__| | |_) | __/ | | |____) | |_) || |_ \\____/| .__/ \\___|_| |_|_____/|____/_____| | | |_| Platform Name : riscv-virtio,qemu Platform Features : medeleg Platform HART Count : 1 Platform IPI Device : aclint-mswi Platform Timer Device : aclint-mtimer @ 10000000Hz Platform Console Device : uart8250 Platform HSM Device : --- Platform PMU Device : --- Platform Reboot Device : sifive_test Platform Shutdown Device : sifive_test Firmware Base : 0x80000000 Firmware Size : 208 KB Runtime SBI Version : 1.0 Domain0 Name : root Domain0 Boot HART : 0 Domain0 HARTs : 0* Domain0 Region00 : 0x02000000-0x0200ffff (I) Domain0 Region01 : 0x80000000-0x8003ffff () Domain0 Region02 : 0x00000000-0xffffffff (R,W,X) Domain0 Next Address : 0x00000000 Domain0 Next Arg1 : 0x87e00000 Domain0 Next Mode : S-mode Domain0 SysReset : yes Boot HART ID : 0 Boot HART Domain : root Boot HART Priv Version : v1.12 Boot HART Base ISA : rv32imafdch Boot HART ISA Extensions : time,sstc Boot HART PMP Count : 16 Boot HART PMP Granularity : 4 Boot HART PMP Address Bits: 32 Boot HART MHPM Count : 16 Boot HART MIDELEG : 0x00001666 Boot HART MEDELEG : 0x00f0b509 ひとまず正しく動いてそう ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:4","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"ldがriscv32向けのelfを吐けない 本の5.ブートの通りにkernel.c, kernel.ldを作成し、run.shでビルドしようとすると、以下のエラーが出た ❯ ./run.sh + QEMU=qemu-system-riscv32 + CC=clang + CFLAGS='-std=c11 -O2 -g3 -Wall -Wextra --target=riscv32 -ffreestanding -nostdlib' + clang -std=c11 -O2 -g3 -Wall -Wextra --target=riscv32 -ffreestanding -nostdlib -Wl,-Tkernel.ld -Wl,-Map=kernel.map -o kernel.elf kernel.c /usr/bin/ld: unrecognised emulation mode: elf32lriscv Supported emulations: elf_x86_64 elf32_x86_64 elf_i386 elf_iamcu elf_l1om elf_k1om i386pep i386pe clang: error: ld command failed with exit code 1 (use -v to see invocation) 手元の環境のClangはリンカとしてldを呼んでいるが、ldのターゲットにriscv32がない模様 一旦以下のようにld.lldを別途呼び出すようにしたら、ビルドできるようになった (Clangが呼び出すリンカを変更できないか探ったが、よく分からなかった) #!/bin/bash set -xue # QEMUの実行バイナリへのパス QEMU=qemu-system-riscv32 CC=clang LINKER=ld.lld # コンパイルオプション CFLAGS=\"-c -std=c11 -O2 -g3 -Wall -Wextra --target=riscv32 -ffreestanding -nostdlib -mno-relax\" # カーネルをビルド $CC $CFLAGS -o kernel.o kernel.c $LINKER -m elf32lriscv -L/lib -Tkernel.ld -Map=kernel.map kernel.o -o kernel.elf # QEMUを起動 $QEMU -machine virt -bios default -nographic -serial mon:stdio --no-reboot -kernel kernel.elf ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:5","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"参考にさせていただいたサイト ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:6","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"mikiken (Kentaro Miki) ","date":"2023-08-20","objectID":"/profile/:0:0","tags":null,"title":"Profile","uri":"/profile/"},{"categories":null,"content":"About me Undergraduate student at Kobe University Department of Electrical and Electronic Engineering CAMPHOR- Core Member ","date":"2023-08-20","objectID":"/profile/:0:1","tags":null,"title":"Profile","uri":"/profile/"},{"categories":null,"content":"Interests Low-Layer programming, System Programming Language Processor Operating System Home automation ","date":"2023-08-20","objectID":"/profile/:0:2","tags":null,"title":"Profile","uri":"/profile/"},{"categories":null,"content":"Experiences Participate in Security Camp 2022 Online Development Course, C Compiler Workshop Internship at KLab Inc. (2023/08/24 ~ 2023/08/30) KLab Expert Camp 6th (TCP/IP Protocol Stack Homebrew Development #4) Internship at Turing Inc. (2023/09/11 ~ 2023/09/26) UX Engineering Team ","date":"2023-08-20","objectID":"/profile/:0:3","tags":null,"title":"Profile","uri":"/profile/"},{"categories":null,"content":"Links GitHub : mikiken Twitter : @mikikeen Misskey : @mikiken@social.camph.net Discord : mikiken SpeakerDeck : mikiken Zenn : mikiken ","date":"2023-08-20","objectID":"/profile/:0:4","tags":null,"title":"Profile","uri":"/profile/"}]