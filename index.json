[{"categories":null,"content":"この記事は CAMPHOR- Advent Calendar 2023 の13日目の記事です。 ","date":"2023-12-13","objectID":"/posts/td4-fpga/:0:0","tags":null,"title":"「CPUの創りかた」のTD4をFPGAで実装してみた","uri":"/posts/td4-fpga/"},{"categories":null,"content":"はじめに 「CPUの創りかた」という本をご存知でしょうか？2003年に出版された本で、汎用ロジックIC(74シリーズ)を使って、簡単な4bitのCPUを作ります。本のタイトルから、デジタル回路の話が多そうだという印象を持つかもしれませんが、LED点灯回路の抵抗値の計算といった、基本的なアナログ回路の内容から丁寧に解説されている名著です。今年で発売から20年を迎えますが、未だに根強い人気を誇っており、現在では30刷以上重版されているようです。 僕の通う大学では、3年生後期に、FPGAで何らかのデジタル回路を実装するという実験があります。そこで、この本の内容をFPGAで実装してみました。 大学の実験で「CPUの創りかた」のTD4をFPGAで実装してみた pic.twitter.com/Oqk6r73JyZ — mikiken (@mikikeen) November 6, 2023 ","date":"2023-12-13","objectID":"/posts/td4-fpga/:1:0","tags":null,"title":"「CPUの創りかた」のTD4をFPGAで実装してみた","uri":"/posts/td4-fpga/"},{"categories":null,"content":"作ったもの 「CPUの創りかた」では、TD4という4bitのCPUを段階を分けて作っていきます。 TD4の仕様をざっくり説明すると、 命令長8bit (オペコード 4bit, オペランド 4bit) 演算用のレジスタ(4bit)が2つ という感じです。 実行できる命令としては、以下の12種類があります。 ADD A, Im ADD B, Im MOV A, Im MOV B, Im MOV A, B MOV B, A JMP Im JNC Im キャリーフラグが0のとき、即値Imで指定されたアドレスにジャンプする IN A 入力端子からデータを入力し、Aレジスタに代入する IN B 入力端子からデータを入力し、Bレジスタに代入する OUT B Bレジスタの値を出力端子に出力する なお、OUT A命令は存在しない。 OUT Im 即値Imを出力端子に出力する なお、リポジトリはこれです。 あと、学校の授業で成果発表したときのスライドを一応載せときます ","date":"2023-12-13","objectID":"/posts/td4-fpga/:2:0","tags":null,"title":"「CPUの創りかた」のTD4をFPGAで実装してみた","uri":"/posts/td4-fpga/"},{"categories":null,"content":"実装方法 基本的には本に書いてある通りに実装しました。具体的には、 レジスタ ALU プログラムカウンタ 命令デコーダ ROM の順に実装しました。 なお、実装に使った(実験で渡された)FPGAボードは、PowerMedusa MU500-RXです。 三菱電機マイコン機器ソフトウエアが出しているFPGAボードで、AlteraのEP4CE30F23I7NっていうFPGAが載ってるらしい。 ほぼ本に書いてある順で実装したんですが、ROMだけ実装方針に悩んだので最後に回しました。 本だと8bitをDIPスイッチを16個並べてROMを表現しているんですが、今回使ったFPGAボードには8bitのDIPスイッチが2個しか搭載されていませんでした。 そこで、Verilogを使って、ROMの各アドレスに対して決め打ちした命令を返す素子を書き、ROMを表現することにしました。 module rom( input [3:0] address, output [7:0] data ); function [7:0] select; input [3:0] address; case (address) //Ramen timer! 4'b0000: select = 8'b10110111; // OUT 0111 4'b0001: select = 8'b00000001; // ADD A,0001 4'b0010: select = 8'b11100001; // JNC 0001 4'b0011: select = 8'b00000001; // ADD A,0001 4'b0100: select = 8'b11100011; // JNC 0011 4'b0101: select = 8'b10110110; // OUT 0110 4'b0110: select = 8'b00000001; // ADD A,0001 4'b0111: select = 8'b11100110; // JNC 0110 4'b1000: select = 8'b00000001; // ADD A,0001 4'b1001: select = 8'b11101000; // JNC 1000 4'b1010: select = 8'b10110000; // OUT 0000 4'b1011: select = 8'b10110100; // OUT 0100 4'b1100: select = 8'b00000001; // ADD 0001 4'b1101: select = 8'b11101010; // JNC 1010 4'b1110: select = 8'b10111000; // OUT 1000 4'b1111: select = 8'b11111111; // JMP 1111 default: select = 8'bxxxxxxxx; /* //LED chikachika! 4'b0000: select = 8'b10110011; // OUT 0011 4'b0001: select = 8'b10110110; // OUT 0110 4'b0010: select = 8'b10111100; // OUT 1100 4'b0011: select = 8'b10111000; // OUT 1000 4'b0100: select = 8'b10111000; // OUT 1000 4'b0101: select = 8'b10111100; // OUT 1100 4'b0110: select = 8'b10110110; // OUT 0110 4'b0111: select = 8'b10110011; // OUT 0011 4'b1000: select = 8'b10110001; // OUT 0001 4'b1001: select = 8'b11110000; // JMP 0000 4'b1010: select = 8'b00000000; 4'b1011: select = 8'b00000000; 4'b1100: select = 8'b00000000; 4'b1101: select = 8'b00000000; 4'b1110: select = 8'b00000000; 4'b1111: select = 8'b00000000; default: select = 8'bxxxxxxxx; */ endcase endfunction assign data = select(address); endmodule 今回使ったFPGAボードはQuartusが使えるので、このVerilogのコードを回路図上のコンポーネントとしてexportし、ROMを実装しました。 ","date":"2023-12-13","objectID":"/posts/td4-fpga/:3:0","tags":null,"title":"「CPUの創りかた」のTD4をFPGAで実装してみた","uri":"/posts/td4-fpga/"},{"categories":null,"content":"感想など ブラックボックスだと思っていたCPUについて、少しは理解が深まったと思います。今度はもう少し大規模なCPUをHDLで書いてみたいですね。 どうでもいいことなんですが、気軽に最初のツイートをしたところ、思ったより反響があって驚きました。やはり自作OS, 自作CPU, 自作言語は人類の三大欲求 ","date":"2023-12-13","objectID":"/posts/td4-fpga/:4:0","tags":null,"title":"「CPUの創りかた」のTD4をFPGAで実装してみた","uri":"/posts/td4-fpga/"},{"categories":null,"content":"同じ内容をZennのスクラップにも書いたんですが、こっちにも一応書いとく 本の記述に従い環境構築をしてみた しかし、5. ブートの説明通りにrun.shを記述し実行したところ、以下のようなエラーが出た ❯ ./run.sh + QEMU=qemu-system-riscv32 + qemu-system-riscv32 -machine virt -bios default -nographic -serial mon:stdio --no-reboot qemu-system-riscv32: Unable to load the RISC-V firmware \"opensbi-riscv32-virt-fw_jump.bin\" パッと見た感じ、QEMUが-bios defaultで呼び出すファームウェアが、本の執筆当時とは変わっていそう(?) そこで、run.shを以下のように変更した #!/bin/bash set -xue # QEMUの実行バイナリへのパス QEMU=qemu-system-riscv32 # QEMUを起動 $QEMU -machine virt -bios opensbi-riscv32-generic-fw_dynamic.bin -nographic -serial mon:stdio --no-reboot すると、エラー自体は出なくなったが、QEMUを起動しても何も表示されない ❯ ./run.sh + QEMU=qemu-system-riscv32 + qemu-system-riscv32 -machine virt -bios opensbi-riscv32-generic-fw_dynamic.bin -nographic -serial mon:stdio --no-reboot そこで、以下の手順を試した aptで入れたQEMU関係のパッケージを全てアンインストール riscv-gnu-toolchainをソースコードからビルドする QEMUをソースコードからビルドする ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:0","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"aptで入れたQEMU関係のパッケージを全てアンインストール sudo apt-get remove --purge \"qemu-*\" ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:1","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"riscv-gnu-toolchainをソースコードからビルドする ビルドに必要なパッケージをインストールしておく。 sudo apt install -y texinfo bison flex libgmp-dev 環境によっては、上記以外にも足りないパッケージがあるかもしれないので、ビルド実行後にエラーが出たら適宜インストールしてから再実行する。 以下のコマンドを実行し、ソースコードからriscv-gnu-toolchainをビルドする。 cd ~ git clone --depth=1 https://github.com/riscv-collab/riscv-gnu-toolchain.git cd riscv-gnu-toolchain/ ./configure --prefix=/opt/riscv32 --with-arch=rv32i --with-abi=ilp32 sudo make ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:2","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"QEMUをソースコードからビルドする この本が書かれたのが2023年の8月頃なので、当時の安定リリースであるQEMUのv8.0系をソースコードからビルドし、インストールする。 ビルドに必要なパッケージをインストールしておく。 sudo apt install -y pkg-config ninja-build libglib2.0 libpixman-1-dev 環境によっては、上記以外にも足りないパッケージがあるかもしれないので、ビルド実行後にエラーが出たら適宜インストールしてから再実行する。 以下のコマンドを実行する。 mkdir ~/qemu \u0026\u0026 cd ~/qemu git clone --depth=1 --branch stable-8.0 https://github.com/qemu/qemu.git sudo mkdir /opt/qemu-system-riscv32 sudo ./configure --target-list=riscv32-softmmu --prefix=/opt/qemu-system-riscv32/ sudo make -j $(nproc) sudo make install ビルドが完了すると、上の--prefixで指定したパスにqemu-system-riscv32という実行バイナリが生成されているはず。そのディレクトリに対してPATHを通す。 すなわち.bashrcに以下を追加する。 export PATH=\"$PATH:/opt/qemu-system-riscv32/bin\" ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:3","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"動作確認 本の記述通りにrun.shを記述し、実行した。 ❯ ./run.sh + QEMU=qemu-system-riscv32 + qemu-system-riscv32 -machine virt -bios default -nographic -serial mon:stdio --no-reboot OpenSBI v1.2 ____ _____ ____ _____ / __ \\ / ____| _ \\_ _| | | | |_ __ ___ _ __ | (___ | |_) || | | | | | '_ \\ / _ \\ '_ \\ \\___ \\| _ \u003c | | | |__| | |_) | __/ | | |____) | |_) || |_ \\____/| .__/ \\___|_| |_|_____/|____/_____| | | |_| Platform Name : riscv-virtio,qemu Platform Features : medeleg Platform HART Count : 1 Platform IPI Device : aclint-mswi Platform Timer Device : aclint-mtimer @ 10000000Hz Platform Console Device : uart8250 Platform HSM Device : --- Platform PMU Device : --- Platform Reboot Device : sifive_test Platform Shutdown Device : sifive_test Firmware Base : 0x80000000 Firmware Size : 208 KB Runtime SBI Version : 1.0 Domain0 Name : root Domain0 Boot HART : 0 Domain0 HARTs : 0* Domain0 Region00 : 0x02000000-0x0200ffff (I) Domain0 Region01 : 0x80000000-0x8003ffff () Domain0 Region02 : 0x00000000-0xffffffff (R,W,X) Domain0 Next Address : 0x00000000 Domain0 Next Arg1 : 0x87e00000 Domain0 Next Mode : S-mode Domain0 SysReset : yes Boot HART ID : 0 Boot HART Domain : root Boot HART Priv Version : v1.12 Boot HART Base ISA : rv32imafdch Boot HART ISA Extensions : time,sstc Boot HART PMP Count : 16 Boot HART PMP Granularity : 4 Boot HART PMP Address Bits: 32 Boot HART MHPM Count : 16 Boot HART MIDELEG : 0x00001666 Boot HART MEDELEG : 0x00f0b509 ひとまず正しく動いてそう ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:4","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"ldがriscv32向けのelfを吐けない 本の5.ブートの通りにkernel.c, kernel.ldを作成し、run.shでビルドしようとすると、以下のエラーが出た ❯ ./run.sh + QEMU=qemu-system-riscv32 + CC=clang + CFLAGS='-std=c11 -O2 -g3 -Wall -Wextra --target=riscv32 -ffreestanding -nostdlib' + clang -std=c11 -O2 -g3 -Wall -Wextra --target=riscv32 -ffreestanding -nostdlib -Wl,-Tkernel.ld -Wl,-Map=kernel.map -o kernel.elf kernel.c /usr/bin/ld: unrecognised emulation mode: elf32lriscv Supported emulations: elf_x86_64 elf32_x86_64 elf_i386 elf_iamcu elf_l1om elf_k1om i386pep i386pe clang: error: ld command failed with exit code 1 (use -v to see invocation) 手元の環境のClangはリンカとしてldを呼んでいるが、ldのターゲットにriscv32がない模様 一旦以下のようにld.lldを別途呼び出すようにしたら、ビルドできるようになった (Clangが呼び出すリンカを変更できないか探ったが、よく分からなかった) #!/bin/bash set -xue # QEMUの実行バイナリへのパス QEMU=qemu-system-riscv32 CC=clang LINKER=ld.lld # コンパイルオプション CFLAGS=\"-c -std=c11 -O2 -g3 -Wall -Wextra --target=riscv32 -ffreestanding -nostdlib -mno-relax\" # カーネルをビルド $CC $CFLAGS -o kernel.o kernel.c $LINKER -m elf32lriscv -L/lib -Tkernel.ld -Map=kernel.map kernel.o -o kernel.elf # QEMUを起動 $QEMU -machine virt -bios default -nographic -serial mon:stdio --no-reboot -kernel kernel.elf ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:5","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"参考にさせていただいたサイト ","date":"2023-10-26","objectID":"/posts/writing-an-os-in-1000-lines-setup/:0:6","tags":null,"title":"\"Writing an OS in 1000 lines\"の環境構築をしたときのメモ","uri":"/posts/writing-an-os-in-1000-lines-setup/"},{"categories":null,"content":"mikiken (Kentaro Miki) ","date":"2023-08-20","objectID":"/profile/:0:0","tags":null,"title":"Profile","uri":"/profile/"},{"categories":null,"content":"About me Undergraduate student at Kobe University Department of Electrical and Electronic Engineering CAMPHOR- Core Member ","date":"2023-08-20","objectID":"/profile/:0:1","tags":null,"title":"Profile","uri":"/profile/"},{"categories":null,"content":"Interests Low-Layer programming, System Programming Language Processor Operating System Home automation ","date":"2023-08-20","objectID":"/profile/:0:2","tags":null,"title":"Profile","uri":"/profile/"},{"categories":null,"content":"Experiences Participate in Security Camp 2022 Online Development Course, C Compiler Workshop Internship at KLab Inc. (2023/08/24 ~ 2023/08/30) KLab Expert Camp 6th (TCP/IP Protocol Stack Homebrew Development #4) Internship at Turing Inc. (2023/09/11 ~ 2023/09/26) UX Engineering Team ","date":"2023-08-20","objectID":"/profile/:0:3","tags":null,"title":"Profile","uri":"/profile/"},{"categories":null,"content":"Links GitHub : mikiken Twitter : @mikikeen Misskey : @mikiken@social.camph.net Discord : mikiken SpeakerDeck : mikiken Zenn : mikiken ","date":"2023-08-20","objectID":"/profile/:0:4","tags":null,"title":"Profile","uri":"/profile/"}]